/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : App Store Tools
 #	author : miyako
 #	2017/02/10
 #
 # --------------------------------------------------------------------------------*/


#include "4DPluginAPI.h"
#include "4DPlugin.h"


NSURL *appStoreReceiptURL(void)
{
	NSBundle *mainBundle = [NSBundle mainBundle];
	NSURL *url = NULL;

	//appStoreReceiptURL method is not available on older systems
	//https://developer.apple.com/library/content/releasenotes/General/ValidateAppStoreReceipt/Chapters/ValidateLocally.html#//apple_ref/doc/uid/TP40010573-CH1-SW2
#ifdef NSAppKitVersionNumber10_7
	if ((NSAppKitVersionNumber >= NSAppKitVersionNumber10_7))
	{
		url = [mainBundle appStoreReceiptURL];
	}
#endif
	if(!url)
	{
		url = [[[[mainBundle bundleURL]
						 URLByAppendingPathComponent:@"Contents"]
						URLByAppendingPathComponent:@"_MASReceipt"]
					 URLByAppendingPathComponent:@"receipt"];
	}
	return url;
}

NSURL *appleComputerRootCertificateURL(void)
{
	NSBundle *pluginBundle = [NSBundle bundleWithIdentifier:THIS_PLUGIN_UTI];
	NSURL *url = [pluginBundle URLForResource:@"Apple Root CA" withExtension:@"cer"];
	
	return url;
}

#pragma mark

void ASNGetPayload(C_BLOB &payload)
{
	//The receipt is actually a PCKS7 container
	NSData *receipt = [NSData dataWithContentsOfURL:appStoreReceiptURL()];
	if(receipt)
	{
		NSData *certificate = [NSData dataWithContentsOfURL:appleComputerRootCertificateURL()];
		if(certificate)
		{
			//https://gist.github.com/sazameki/3026845
			CMSDecoderRef decoder;
			if(!CMSDecoderCreate(&decoder))
			{
				if(!CMSDecoderUpdateMessage(decoder, [receipt bytes], [receipt length]))
				{
					if(!CMSDecoderFinalizeMessage(decoder))
					{
						CFDataRef dataRef = NULL;
						if(!CMSDecoderCopyContent(decoder, &dataRef))
						{
							{
								size_t numSigners;
								if(!CMSDecoderGetNumSigners(decoder, &numSigners))
								{
									if(numSigners)
									{
										SecPolicyRef policyRef = SecPolicyCreateBasicX509();
										SecTrustRef trustRef;
										CMSSignerStatus signerStatus;
										OSStatus certVerifyResult;
										if(!CMSDecoderCopySignerStatus(decoder, 0, policyRef, TRUE, &signerStatus, &trustRef, &certVerifyResult))
										{
											switch (signerStatus)
											{
												case kCMSSignerValid:/* message was signed and signature verify OK */
												case kCMSSignerInvalidSignature:/* message was signed but had a signature error */
												case kCMSSignerInvalidCert:/* message was signed but an error occurred in verifying the signer's certificate */
													payload.setBytes((const uint8_t *)CFDataGetBytePtr(dataRef), CFDataGetLength(dataRef));
													break;
												default:
													break;
											}
											CFRelease(trustRef);
										}
										CFRelease(policyRef);
									}
								}
								CFRelease(dataRef);
							}
						}
					}
				}
				CFRelease(decoder);
			}
		}
	}
}

inline static int GetIntValueFromASN1Data(const ASN1_Data *asn1Data)
{
	int ret = 0;
	for (int i = 0; i < asn1Data->length; i++)
	{
		ret = (ret << 8) | asn1Data->data[i];
	}
	return ret;
}

void ASNGetPayloadAttribute(int type, C_TEXT &value)
{
	C_BLOB payloadData;
	
	ASNGetPayload(payloadData);
	
	SecAsn1CoderRef asn1Decoder;
	if(!SecAsn1CoderCreate(&asn1Decoder))
	{
		RVNReceiptPayload payload = {NULL};
		if(!SecAsn1Decode(asn1Decoder, payloadData.getBytesPtr(), payloadData.getBytesLength(), kSetOfReceiptAttributeTemplate, &payload))
		{
			RVNReceiptAttribute *anAttr;
			for (int i = 0; (anAttr = payload.attrs[i]); i++)
			{
				if(type == GetIntValueFromASN1Data(&anAttr->type))
				{
					ASN1_Data asn1Data;
					switch (type)
					{
						case 2://bundle_id
						case 3://bundle_version
						case 19://bundle_original_version
							if(!SecAsn1Decode(asn1Decoder, anAttr->value.data, anAttr->value.length, kSecAsn1UTF8StringTemplate, &asn1Data))
							{
								value.setUTF8String((const uint8_t *)asn1Data.data, asn1Data.length);
							}
							break;
						case 4://opaque
						case 5://hash
							{
								C_BLOB temp;
								temp.setBytes((const uint8_t *)anAttr->value.data, anAttr->value.length);
								temp.toHexText(&value);
							}
							break;
						case 12://creation_date
						case 21://expiration_date
							if(!SecAsn1Decode(asn1Decoder, anAttr->value.data, anAttr->value.length, kSecAsn1IA5StringTemplate, &asn1Data))
							{
								value.setUTF8String((const uint8_t *)asn1Data.data, asn1Data.length);
							}
							break;
						default:
							break;
					}
				}
			}
		}
		SecAsn1CoderRelease(asn1Decoder);
	}
}

#pragma mark -

int ASNGetUTF8String(NSString *string, unsigned char* buffer, NSUInteger bufferSize)
{
	NSUInteger len = 0;
	NSUInteger lenlen = 0;
	unsigned int i, clen;
	unsigned int size = 0;
	char *p;
	
	if(string)
	{
		len = [string lengthOfBytesUsingEncoding:NSUTF8StringEncoding];
		
		if(len <= 0x7F)
		{
			lenlen = 0;
		}else{
			if(len <= 0xFF)
			{
				lenlen = 1;
			}else{
				if(len <= 0xFFFF)
				{
					lenlen = 2;
				}else{
					if(len <= 0xFFFFFF)
					{
						lenlen = 3;
					}else{
						if(len <= 0xFFFFFFFF)
						{
							lenlen = 4;
						}
					}
				}
			}
		}
		
		size = 2 + lenlen + len;
		
		if(bufferSize)
		{
			clen = len + 1;
			p = (char *)malloc(clen);
			[string	getCString:p maxLength:clen encoding:NSUTF8StringEncoding];
			
			*buffer = 0x0C;//tag for UTF8STRING
			buffer++;
			
			if(!lenlen)
			{
				*buffer = len;//length <= 127
				buffer++;
			}else{
				*buffer = len & 0x80;
				buffer++;
				
				switch (lenlen)
				{
					case 2:
						*buffer = len >>  8;
						buffer++;
						*buffer = len;
						buffer++;
						break;
					case 3:
						*buffer = len >>  16;
						buffer++;
						*buffer = len >>  8;
						buffer++;
						*buffer = len;
						buffer++;
						break;
					case 4:
						*buffer = len >>  24;
						buffer++;
						*buffer = len >>  16;
						buffer++;
						*buffer = len >>  8;
						buffer++;
						*buffer = len;
						buffer++;
						break;
					default:
						break;
				}
			}
			for(i = 0; i < len; i++)
			{
				*buffer = p[i];
				buffer++;
			}
			free(p);
		}
		
	}
	
	return size;
}

void ASNGetUTF8String(C_TEXT &string, CUTF8String &utf8_string)
{
	NSString *s = string.copyUTF16String();
	int len = ASNGetUTF8String(s, NULL, 0L);
	unsigned char *u = (unsigned char *)malloc(len);
	
	if(u)
	{
		ASNGetUTF8String(s, u, len);
		utf8_string = CUTF8String(u, len);
		free(u);
	}
	
	[s release];
}

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params)
{
	try
	{
		PA_long32 pProcNum = selector;
		sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
		PackagePtr pParams = (PackagePtr)params->fParameters;

		CommandDispatcher(pProcNum, pResult, pParams); 
	}
	catch(...)
	{

	}
}

void CommandDispatcher (PA_long32 pProcNum, sLONG_PTR *pResult, PackagePtr pParams)
{
	switch(pProcNum)
	{
			/*
		case kInitPlugin :
		case kServerInitPlugin :
			OpenSSL_add_all_digests(); // Required for PKCS7_verify to work
			break;
			*/
// --- Receipt

		case 1 :
			RECEIPT_Get_hash(pResult, pParams);
			break;

// --- Bundle

		case 2 :
			BUNDLE_Get_identifier(pResult, pParams);
			break;

		case 3 :
			BUNDLE_Get_version(pResult, pParams);
			break;

// --- GUID

		case 4 :
			GUID_Compute_hash(pResult, pParams);
			break;

		case 5 :
			GUID_Get_identifier(pResult, pParams);
			break;

// --- Exit

		case 6 :
			PA_RunInMainProcess((PA_RunInMainProcessProcPtr)EXIT_173, NULL);

			break;

// --- Receipt

		case 7 :
			RECEIPT_Get_identifier(pResult, pParams);
			break;

		case 8 :
			RECEIPT_Get_opaque(pResult, pParams);
			break;

		case 9 :
			RECEIPT_Get_version(pResult, pParams);
			break;

		case 10 :
			RECEIPT_Get_creation_date(pResult, pParams);
			break;

		case 11 :
			RECEIPT_Get_expiration_date(pResult, pParams);
			break;

		case 12 :
			RECEIPT_Get_original_version(pResult, pParams);
			break;

	}
}

// ------------------------------------ Bundle ------------------------------------

#pragma mark -

void BUNDLE_Get_identifier(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT returnValue;

	returnValue.setUTF16String([[NSBundle mainBundle]bundleIdentifier]);

	returnValue.setReturn(pResult);
}

void BUNDLE_Get_version(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT returnValue;

	returnValue.setUTF16String([[[NSBundle mainBundle]infoDictionary]objectForKey:@"CFBundleShortVersionString"]);

	returnValue.setReturn(pResult);
}

// ------------------------------------- GUID -------------------------------------

#pragma mark -

NSData * CreateDataFromHexString(C_TEXT &hexstr)
{
	NSString *hex = hexstr.copyUTF16String();
	NSMutableData * data = [[NSMutableData alloc]init];
	
	unsigned int i;
	char byte;
	
	if(([hex length] % 2) == 0)
	{
		for(i = 0 ; i < [hex length]; i+= 2)
		{
			byte = strtoul([[hex substringWithRange:NSMakeRange(i,2)]UTF8String], NULL, 16);
			[data appendBytes:&byte length:1];
		}
	}
	
	[hex release];
	
	return data;
}

void GetGUID(C_TEXT &guid)
{
	//https://developer.apple.com/library/content/releasenotes/General/ValidateAppStoreReceipt/Chapters/ValidateLocally.html#//apple_ref/doc/uid/TP40010573-CH1-SW14
	/*
	mach_port_t               master_port;
	CFMutableDictionaryRef    matchingDict;
	io_iterator_t             iterator;
	io_object_t               service;
	CFDataRef                 macAddress = nil;
	
	if (IOMasterPort(MACH_PORT_NULL, &master_port) == KERN_SUCCESS)
	{
		matchingDict = IOBSDNameMatching(master_port, 0, "en0");
		if (matchingDict)
		{
			if (IOServiceGetMatchingServices(master_port, matchingDict, &iterator) == KERN_SUCCESS)
			{
				while((service = IOIteratorNext(iterator)) != 0)
				{
					io_object_t parentService;
					if (IORegistryEntryGetParentEntry(service, kIOServicePlane, &parentService) == KERN_SUCCESS)
					{
						if(macAddress) CFRelease(macAddress);
						macAddress = (CFDataRef) IORegistryEntryCreateCFProperty(parentService, CFSTR("IOMACAddress"), kCFAllocatorDefault, 0);
						IOObjectRelease(parentService);
					}
					IOObjectRelease(service);
				}
			}
			if(macAddress)
			{
				guid.setUTF16String([[[[(NSData *)macAddress description]
					stringByReplacingOccurrencesOfString:@"<" withString:@""]
					stringByReplacingOccurrencesOfString:@" " withString:@""]
					stringByReplacingOccurrencesOfString:@">" withString:@""]);
				CFRelease(macAddress);
			}
		}
	}
	 */
	NSArray *interfaces = (NSArray *)SCNetworkInterfaceCopyAll();
	if(interfaces)
	{
		for(unsigned int i = 0; i < [interfaces count]; ++i)
		{
			SCNetworkInterfaceRef interface = (SCNetworkInterfaceRef)[interfaces objectAtIndex:i];
			
			if(interface)
			{
				if ([(NSString *)SCNetworkInterfaceGetBSDName(interface) isEqualToString:@"en0"])
				{
					guid.setUTF16String([(NSString *)SCNetworkInterfaceGetHardwareAddressString(interface) stringByReplacingOccurrencesOfString:@":" withString:@""]);
					break;
				}
			}
		}
	}
}

void GUID_Compute_hash(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	C_TEXT Param3;
	C_TEXT returnValue;

	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);

	NSData *guid = CreateDataFromHexString(Param1);
	NSData *opaque = CreateDataFromHexString(Param2);
	
	CUTF8String uti;
	ASNGetUTF8String(Param3, uti);
	
	CC_SHA1_CTX ctx;
	unsigned char digest[CC_SHA1_DIGEST_LENGTH];
	
	if(CC_SHA1_Init(&ctx))
	{
		CC_SHA1_Update(&ctx, [guid bytes], [guid length]);
		CC_SHA1_Update(&ctx, [opaque bytes], [opaque length]);
		CC_SHA1_Update(&ctx, uti.c_str(), uti.length());
		CC_SHA1_Final(digest, &ctx);
		
		C_BLOB temp;
		temp.setBytes((const uint8_t *)digest, CC_SHA1_DIGEST_LENGTH);
		temp.toHexText(&returnValue);
	}
	
	[guid release];
	[opaque release];
	
	returnValue.setReturn(pResult);
}

void GUID_Get_identifier(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT returnValue;

	GetGUID(returnValue);
	
	returnValue.setReturn(pResult);
}

// ------------------------------------- Exit -------------------------------------

#pragma mark -

OSErr GestaltSystemVersion(SInt32* systemVersionMajor, SInt32* systemVersionMinor, SInt32* systemVersionBugFix)
{
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
	OSErr err = noErr;
	
	err = Gestalt(gestaltSystemVersionMajor, systemVersionMajor);
	
	if(err)
		return err;
	
	err = Gestalt(gestaltSystemVersionMinor, systemVersionMinor);
	
	if(err)
		return err;
	
	return Gestalt(gestaltSystemVersionBugFix, systemVersionBugFix);
#pragma clang diagnostic pop	
}

BOOL GestaltSystemVersionCheck(SInt32 major, SInt32 minor, SInt32 fix)
{
	SInt32 systemVersionMajor;
	SInt32 systemVersionMinor;
	SInt32 systemVersionBugFix;
	
	OSErr err = GestaltSystemVersion(&systemVersionMajor, &systemVersionMinor, &systemVersionBugFix);
	
	return ((!err)
					&& (systemVersionMajor >= major)
					&& ((systemVersionMinor > minor)
							|| ((systemVersionMinor== minor) && (systemVersionBugFix >= fix))));
}

void EXIT_173(sLONG_PTR *pResult, PackagePtr pParams)
{
	//minimum version 10.6.6
	//1038 = NSAppKitVersionNumber10_6
	if ((NSAppKitVersionNumber > 1038) || GestaltSystemVersionCheck(10, 6, 6))
	{
		exit(173);
	}
	
}

// ------------------------------------ Receipt -----------------------------------

#pragma mark -

void RECEIPT_Get_hash(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT returnValue;
	
	ASNGetPayloadAttribute(5, returnValue);
	
	returnValue.setReturn(pResult);
}

void RECEIPT_Get_opaque(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT returnValue;
	
	ASNGetPayloadAttribute(4, returnValue);

	returnValue.setReturn(pResult);
}

void RECEIPT_Get_identifier(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT returnValue;
	
	ASNGetPayloadAttribute(2, returnValue);
	
	returnValue.setReturn(pResult);
}

void RECEIPT_Get_version(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT returnValue;

	ASNGetPayloadAttribute(3, returnValue);

	returnValue.setReturn(pResult);
}

void RECEIPT_Get_creation_date(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT returnValue;

	ASNGetPayloadAttribute(12, returnValue);

	returnValue.setReturn(pResult);
}

void RECEIPT_Get_expiration_date(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT returnValue;

	ASNGetPayloadAttribute(21, returnValue);

	returnValue.setReturn(pResult);
}

void RECEIPT_Get_original_version(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT returnValue;

	ASNGetPayloadAttribute(19, returnValue);
	
	returnValue.setReturn(pResult);
}